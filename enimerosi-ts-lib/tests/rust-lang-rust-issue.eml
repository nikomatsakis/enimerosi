Return-Path: <niko@alum.mit.edu>
Received: from compute2.internal (compute2.nyi.internal [10.202.2.46])
	 by sloti48n36 (Cyrus 3.7.0-alpha0-841-g7899e99a45-fm-20220811.002-g7899e99a) with LMTPA;
	 Fri, 02 Sep 2022 14:03:04 -0400
X-Cyrus-Session-Id: sloti48n36-1662141784-1506582-2-12877956131440539152
X-Sieve: CMU Sieve 3.0
X-Spam-known-sender: yes ("Address notifications@github.com in From header is in
 addressbook"); in-addressbook
X-Spam-sender-reputation: 0 (email)
X-Spam-score: 0.0
X-Spam-hits: BAYES_00 -1.9, HEADER_FROM_DIFFERENT_DOMAINS 0.25, HTML_MESSAGE 0.001,
  MAILING_LIST_MULTI -1, ME_DMARC_IN_FMWL -0.001, ME_HAS_VSSU 0.001,
  ME_SC_NH -0.001, ME_SENDERREP_DENY 4, RCVD_IN_DNSWL_NONE -0.0001,
  RCVD_IN_MSPIKE_H2 -0.001, SPF_HELO_PASS -0.001, SPF_PASS -0.001,
  T_KAM_HTML_FONT_INVALID 0.01, T_SCC_BODY_TEXT_LINE -0.01, LANGUAGES en,
  BAYES_USED user, SA_VERSION 3.4.6
X-Spam-source: IP='40.107.220.49',
  Host='mail-co1nam11on2049.outbound.protection.outlook.com', Country='US',
  FromHeader='com', MailFrom='edu'
X-Spam-charsets: plain='UTF-8', html='UTF-8'
X-Resolved-to: nikomatsakis@fastmail.fm
X-Delivered-to: nikomatsakis@fastmail.fm
X-Original-Delivered-to: niko@alum.mit.edu
X-Mail-from: niko@alum.mit.edu
Received: from mx1 ([10.202.2.200])
  by compute2.internal (LMTPProxy); Fri, 02 Sep 2022 14:03:04 -0400
Received: from mx1.messagingengine.com (localhost [127.0.0.1])
	by mailmx.nyi.internal (Postfix) with ESMTP id 1209323C0080
	for <nikomatsakis@fastmail.fm>; Fri,  2 Sep 2022 14:03:03 -0400 (EDT)
Received: from mx1.messagingengine.com (localhost [127.0.0.1])
    by mx1.messagingengine.com (Authentication Milter) with ESMTP
    id C4D7D21E20E;
    Fri, 2 Sep 2022 14:03:03 -0400
ARC-Seal: i=2; a=rsa-sha256; cv=pass; d=messagingengine.com; s=fm1; t=
    1662141783; b=gEyy8gHoo8YeEHZkEPX4sHeaeWovHSYPB70pYG6iyzJgEnyI6v
    YTvvT7XwhAEtHbENvAo46GpwQQJH60/cgJAQUTze0ZZ8V7udSFnC/Q25eQISoPFA
    xTfjXt57lmsy7Ae5UoWRLdjjYwSxmopalavm9EgQ8MIXYnqM3/pSKm2GvfJQ/rTg
    ktaiy2Uc/NcdxMh/u0my0Rvq/btsPePLodO6YLMEB2BTx2qEwwuB/Eox1R9g8DPp
    T1+qUMEhIjeYCeZnN7Et5jQGedMD45ZIc2IPelN9DIem8lIh6qlV+hyNzNcjDgsr
    R1rNUgJyaelFfk9fk5GD+ZRWXFD9xk4uWD9A==
ARC-Message-Signature: i=2; a=rsa-sha256; c=relaxed/relaxed; d=
    messagingengine.com; h=resent-from:date:from:reply-to:to:cc
    :message-id:subject:mime-version:content-type
    :content-transfer-encoding:list-id:list-archive:list-post
    :list-unsubscribe; s=fm1; t=1662141783; bh=K62vSpaNLK/0iiVsimU3m
    yNpKNTImmoNLo2X3QiLv1Q=; b=Svl9GlMxWeUwFv8J3mHyik9G7Vc0Pf5tR4lR0
    LUq7vIpdDyd3D+M75iJgNjLWH0eE60A+OChJJd7vs4C4Pic8fFBQjRhBYZf3DQBB
    TyxsLGo5vrGgJCXRywG2sddC/9qH2BYpEr+KNH5nPU+L5XVhoKPOrGXPzcLv4FFj
    QK+FTjiFEaQ1/uSR7/6KgbykNcoEzgqGGAy8Sph1VKM+XIHaBPDcOMzueWFJ/B+W
    caFZtvX2qaQ7arDhLK7cb563UhI9qeAJZBQaV/VZxHf27QjAFbFV1X7pFwi17gaj
    YaZxKZ6OH8R7M/R7kCP42fVI7e6838QBJ+TonpSi77aocIXFg==
ARC-Authentication-Results: i=2; mx1.messagingengine.com;
    x-csa=none;
    x-me-sender=none;
    x-ptr=fail smtp.helo=NAM11-CO1-obe.outbound.protection.outlook.com
    policy.ptr=mail-co1nam11on2049.outbound.protection.outlook.com;
    bimi=none (No BIMI records found);
    arc=pass (as.1.microsoft.com=pass, ams.1.microsoft.com=pass)
    smtp.remote-ip=40.107.220.49;
    x-arc-dkim=pass (signature was verified) header.d=github.com
    x-arc-instance=1 x-arc-domain=microsoft.com
    (Trusted from aar.1.microsoft.com);
    x-arc-spf=pass (sender ip is   192.30.252.208)
    smtp.rcpttodomain=alum.mit.edu smtp.mailfrom=github.com
    x-arc-instance=1 x-arc-domain=microsoft.com
    (Trusted from aar.1.microsoft.com);
    dkim=pass (1024-bit rsa key sha256) header.d=github.com
    header.i=@github.com header.b=goNFAadK header.a=rsa-sha256
    header.s=pf2014 x-bits=1024;
    dkim=pass (1024-bit rsa key sha256) header.d=mitalumprod.onmicrosoft.com
    header.i=@mitalumprod.onmicrosoft.com header.b=RnolcFRc
    header.a=rsa-sha256 header.s=selector2-mitalumprod-onmicrosoft-com
    x-bits=1024;
    dmarc=pass policy.dwl=pass policy.published-domain-policy=reject
    policy.applied-disposition=none policy.evaluated-disposition=none
    (p=reject,has-list-id=yes,d=none,d.eval=none) policy.policy-from=p
    header.from=github.com;
    iprev=pass smtp.remote-ip=40.107.220.49
    (mail-co1nam11on2049.outbound.protection.outlook.com);
    spf=pass smtp.mailfrom=niko@alum.mit.edu
    smtp.helo=NAM11-CO1-obe.outbound.protection.outlook.com
X-ME-Authentication-Results: mx1.messagingengine.com;
    x-aligned-from=fail;
    x-return-mx=pass header.domain=github.com policy.is_org=yes
      (MX Records found: alt3.aspmx.l.google.com,alt4.aspmx.l.google.com,alt1.aspmx.l.google.com,alt2.aspmx.l.google.com,aspmx.l.google.com);
    x-return-mx=pass smtp.domain=alum.mit.edu policy.org_domain=mit.edu
      policy.is_org=no
      (MX Records found: alum-mit-edu.mail.protection.outlook.com);
    x-tls=pass smtp.version=TLSv1.2 smtp.cipher=ECDHE-RSA-AES256-GCM-SHA384
      smtp.bits=256/256;
    x-vs=clean score=-31 state=0
Authentication-Results: mx1.messagingengine.com;
    x-csa=none;
    x-me-sender=none;
    x-ptr=fail smtp.helo=NAM11-CO1-obe.outbound.protection.outlook.com
      policy.ptr=mail-co1nam11on2049.outbound.protection.outlook.com
Authentication-Results: mx1.messagingengine.com;
    bimi=none (No BIMI records found)
Authentication-Results: mx1.messagingengine.com;
    arc=pass (as.1.microsoft.com=pass, ams.1.microsoft.com=pass)
      smtp.remote-ip=40.107.220.49;
    x-arc-dkim=pass (signature was verified) header.d=github.com
      x-arc-instance=1 x-arc-domain=microsoft.com
      (Trusted from aar.1.microsoft.com);
    x-arc-spf=pass (sender ip is   192.30.252.208)
      smtp.rcpttodomain=alum.mit.edu smtp.mailfrom=github.com
      x-arc-instance=1 x-arc-domain=microsoft.com
      (Trusted from aar.1.microsoft.com)
Authentication-Results: mx1.messagingengine.com;
    dkim=pass (1024-bit rsa key sha256) header.d=github.com
      header.i=@github.com header.b=goNFAadK header.a=rsa-sha256
      header.s=pf2014 x-bits=1024;
    dkim=pass (1024-bit rsa key sha256) header.d=mitalumprod.onmicrosoft.com
      header.i=@mitalumprod.onmicrosoft.com header.b=RnolcFRc
      header.a=rsa-sha256 header.s=selector2-mitalumprod-onmicrosoft-com
      x-bits=1024;
    dmarc=pass policy.dwl=pass policy.published-domain-policy=reject
      policy.applied-disposition=none policy.evaluated-disposition=none
      (p=reject,has-list-id=yes,d=none,d.eval=none) policy.policy-from=p
      header.from=github.com;
    iprev=pass smtp.remote-ip=40.107.220.49
      (mail-co1nam11on2049.outbound.protection.outlook.com);
    spf=pass smtp.mailfrom=niko@alum.mit.edu
      smtp.helo=NAM11-CO1-obe.outbound.protection.outlook.com
X-ME-VSSU: VW5zdWI9aHR0cHM6Ly9naXRodWIuY29tL25vdGlmaWNhdGlvbnMvdW5zdWJzY3JpYmUtYX
    V0aC9BQUJGNFpRQU1SVUFFNFlMUlFYRFdOVFY0STZOSEFOQ05GU002QUFBQUFBUURQSVhQ
    NA
X-ME-VSSU: VW5zdWI9aHR0cHM6Ly9naXRodWIuY29tL25vdGlmaWNhdGlvbnMvdW5zdWJzY3JpYmUvQU
    FCRjRaVVhGQzRSRklOSkxWUlJKNUxWNEk2TkhBTkNORlNNNkFBQUFBQVFEUElYUDQ
X-ME-VSSU: VW5zdWI9bWFpbHRvOnVuc3ViK0FBQkY0WlZRUENCSUlPR1BIRzRLM1I2QkQ1MzVIRVZCTk
    hIRkNGWjNWNEByZXBseS5naXRodWIuY29t
X-ME-VSCause: gggruggvucftvghtrhhoucdtuddrgedvfedrvdeltddguddvvdcutefuodetggdotefrod
    ftvfcurfhrohhfihhlvgemucfhrghsthforghilhdpggftfghnshhusghstghrihgsvgdp
    uffrtefokffrpgfnqfghnecuuegrihhlohhuthemuceftddtnecusecvtfgvtghiphhivg
    hnthhsucdlqddutddtmdenogfuuhhsphgvtghtffhomhgrihhnucdlgeelmdenhdfknhhv
    ihhsihgslhgvucifohhrughsucdlvddtmdenucfjughrpeffhfhrvfevkffugggtgfhpje
    egudfjsegrjeerredttdejnecuhfhrohhmpefpihhkohcuofgrthhsrghkihhsuceonhho
    thhifhhitggrthhiohhnshesghhithhhuhgsrdgtohhmqeenucggtffrrghtthgvrhhnpe
    ffudegtdeiffdutddtgfffleetffffffehgfefudetjedtheduteduteetgfejkeenucff
    ohhmrghinheprhhushhtqdhlrghnghdrohhrghdpghhithhhuhgsrdhiohdphhgrtghkmh
    gurdhiohdpghhithhhuhgsrdgtohhmnecukfhppeegtddruddtjedrvddvtddrgeelpddu
    ledvrdeftddrvdehvddrvddtkeenucevlhhushhtvghrufhiiigvpedtnecurfgrrhgrmh
    epihhnvghtpeegtddruddtjedrvddvtddrgeelpdhhvghloheppfetofduuddqvefquddq
    ohgsvgdrohhuthgsohhunhgurdhprhhothgvtghtihhonhdrohhuthhlohhokhdrtghomh
    dpmhgrihhlfhhrohhmpeeonhhikhhosegrlhhumhdrmhhithdrvgguuheq
X-ME-VSScore: -31
X-ME-VSCategory: clean
X-ME-CSA: none
Received-SPF: pass
    (alum.mit.edu: Sender is authorized to use 'niko@alum.mit.edu' in 'mfrom' identity (mechanism 'include:spf.protection.outlook.com' matched))
    receiver=mx1.messagingengine.com;
    identity=mailfrom;
    envelope-from="niko@alum.mit.edu";
    helo=NAM11-CO1-obe.outbound.protection.outlook.com;
    client-ip=40.107.220.49
Received: from NAM11-CO1-obe.outbound.protection.outlook.com (mail-co1nam11on2049.outbound.protection.outlook.com [40.107.220.49])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by mx1.messagingengine.com (Postfix) with ESMTPS
	for <nikomatsakis@fastmail.fm>; Fri,  2 Sep 2022 14:03:02 -0400 (EDT)
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=iy0+u7aO5odY5PWa+fsEmiwnpm3G+QnRAT7TGHDxbJZMIlSLkXs00fCee5RIboiwJ+F/E8oKplQhlbuU2ThgnihSFfEtPg47TPiUorAGa2gZLduDkHYh7kWzgTF0EUQ3Tm2aei227+XE2WxvO1lCkMF80jgKi5CNqQX37rCi014xvBYIxdNGLtFe0ualvRe8dVYXZfpVuyQRAeAZ5AAbeS5M+sD4F/9M+nDdCqsR2zg3y47su7lAM5eYmcxpYzcbfpFla89Y4muW9KpBlTmzc1RQkgkyXfv/+VsIwgu6UpC9aH9cjY7U/6G0aVjTOfcdSX9s/+yO/Q6xMm1rNqqzXw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=K62vSpaNLK/0iiVsimU3myNpKNTImmoNLo2X3QiLv1Q=;
 b=CV+iKhDimK8kGu2d4C120lLCVuIhL7mr5UoLVl6w8Q8vcM/D8QLwAr6Hk09mDDcS5YVDbXwnC5KA8PX4JV1DW/7j+pP1Cv8IeOk4CTp1lEiY8wRCZla2nPN2aBQfekuqWij4oSHTGQyhRoambncRdV46aHgS8ALhi+vpROcVYpDrqXhMs5jYKRMEIWiIwNNd6PtF91e9k9qKBn1ZDt1/0Zx5jtrt1FMtaFzlxbriamaqogE1NBeJ8APgFcItm4BrmO74Ka3pon+hfvKm+AE7MaJihqTyQ60QefDKGt53mdi5saxiue6y/9zOaWOhKLs24D+4Afk3Jze1TZS4ySATWA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass (sender ip is
 192.30.252.208) smtp.rcpttodomain=alum.mit.edu smtp.mailfrom=github.com;
 dmarc=pass (p=reject sp=reject pct=100) action=none header.from=github.com;
 dkim=pass (signature was verified) header.d=github.com; arc=none (0)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=mitalumprod.onmicrosoft.com; s=selector2-mitalumprod-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=K62vSpaNLK/0iiVsimU3myNpKNTImmoNLo2X3QiLv1Q=;
 b=RnolcFRcJoWIpV1KK3hOl3sbNZm6Mzi6cAg69zO713OQORke0Owm1LkGHE4T+Dz7QC1H4Lq4Dk22/zaQw7WyBbd6O4+MsUDW46RvKewL3aCCPa+OYbZ+h5qp47gL62xLMCrtMTEylUOZuX/aZdaR4ey+v6C233xv/WuME39K8pE=
Resent-From: <niko@alum.mit.edu>
Received: from BN9PR03CA0318.namprd03.prod.outlook.com (2603:10b6:408:112::23)
 by CY5PR12MB6276.namprd12.prod.outlook.com (2603:10b6:930:f::6) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.5588.15; Fri, 2 Sep
 2022 18:02:59 +0000
Received: from BN1NAM02FT005.eop-nam02.prod.protection.outlook.com
 (2603:10b6:408:112:cafe::90) by BN9PR03CA0318.outlook.office365.com
 (2603:10b6:408:112::23) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.5588.10 via Frontend
 Transport; Fri, 2 Sep 2022 18:02:59 +0000
Received-SPF: Pass (protection.outlook.com: domain of github.com designates
 192.30.252.208 as permitted sender) receiver=protection.outlook.com;
 client-ip=192.30.252.208; helo=smtp.github.com; pr=C
Received: from smtp.github.com (192.30.252.208) by
 BN1NAM02FT005.mail.protection.outlook.com (10.13.2.124) with Microsoft SMTP
 Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.5588.10 via Frontend Transport; Fri, 2 Sep 2022 18:02:59 +0000
Received: from github-lowworker-b767462.ash1-iad.github.net (github-lowworker-b767462.ash1-iad.github.net [10.56.120.90])
	by smtp.github.com (Postfix) with ESMTP id 3111384010E
	for <niko@alum.mit.edu>; Fri,  2 Sep 2022 11:02:59 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=github.com;
	s=pf2014; t=1662141779;
	bh=K62vSpaNLK/0iiVsimU3myNpKNTImmoNLo2X3QiLv1Q=;
	h=Date:From:Reply-To:To:Cc:Subject:List-ID:List-Archive:List-Post:
	 List-Unsubscribe:From;
	b=goNFAadKcY7K5J+RE4dv3QIo8e+D560D8SUbDUfl5S6VE8k2UbL/0MeAevf+xrifz
	 fqeUoiW8tfCPH2zXb33M+LYfPkXXcIDNSp5SIFfFokAF22+d/vQxwMc53HUEbuQGyl
	 UV9o7vS0tte3NxtmBemuXXXkxmg1tPeFI8BzmEZc=
Date: Fri, 02 Sep 2022 11:02:59 -0700
From: Niko Matsakis <notifications@github.com>
Reply-To: rust-lang/rust <reply+AABF4ZVQPCBIIOGPHG4K3R6BD535HEVBNHHFCFZ3V4@reply.github.com>
To: rust-lang/rust <rust@noreply.github.com>
Cc: Niko Matsakis <niko@alum.mit.edu>, 
 Your activity <your_activity@noreply.github.com>
Message-ID: <rust-lang/rust/issues/101336@github.com>
Subject: [rust-lang/rust] Commit to safety rules for dyn trait upcasting
 (Issue #101336)
Mime-Version: 1.0
Content-Type: multipart/alternative;
 boundary="--==_mimepart_631245531fc5f_3e85d4d02824f4";
 charset=UTF-8
Content-Transfer-Encoding: 7bit
Precedence: list
X-GitHub-Sender: nikomatsakis
X-GitHub-Recipient: nikomatsakis
X-GitHub-Reason: your_activity
List-ID: rust-lang/rust <rust.rust-lang.github.com>
List-Archive: https://github.com/rust-lang/rust
List-Post: <mailto:reply+AABF4ZVQPCBIIOGPHG4K3R6BD535HEVBNHHFCFZ3V4@reply.github.com>
List-Unsubscribe: <mailto:unsub+AABF4ZVQPCBIIOGPHG4K3R6BD535HEVBNHHFCFZ3V4@reply.github.com>,
 <https://github.com/notifications/unsubscribe/AABF4ZUXFC4RFINJLVRRJ5LV4I6NHANCNFSM6AAAAAAQDPIXP4>
X-Auto-Response-Suppress: DR, RN, NRN, OOF, AutoReply
X-GitHub-Recipient-Address: niko@alum.mit.edu
X-EOPAttributedMessage: 0
X-EOPTenantAttributedMessage: 3326b102-c043-408b-a990-b89e477d582f:0
X-MS-PublicTrafficType: Email
X-MS-Office365-Filtering-Correlation-Id: 629e90d8-0fa9-42a1-5939-08da8d0d5f05
X-MS-TrafficTypeDiagnostic: CY5PR12MB6276:EE_
X-LD-Processed: 3326b102-c043-408b-a990-b89e477d582f,ExtAddr,ExtFwd
X-MS-Exchange-SenderADCheck: 0
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info:
	RiVbeZ73amFiSAHOW8ty0AZvY5gC3HoXDYP9D3QIqic4OcqqnahU7vl04qBva4q6R25xGVsz/mz2WW0PBkMxWY4yJ5A4eY9xuz0948Futq509gcISNR5IMsZ1yZo2xr12fGOMvsSlymeGcYYm2sftgynikY1qlhs2vuv8qHF8Tr+Yn1CHoY56CwF/5nrWrxm1LT+4xWKVgCIYUFRwRRNm05HWdh0BDyMJQoOPSH+SGHO6CurVkrDqnGlYZMY4jsBES5Sm8pHsBZDR7JnuGl5U6f4VwAnn05MUXp0MIf3ufqX2bHFRj0C4T88Xu2PnHVHF8RM1PCZXA6OFYnBW7YNFew/n7Zgkr6frXe4J4cEE0KFdWiqCkiXGnVVmAl/8hAQ1lIQpxTUUoOEuztJWQuOtlhDq338qMnfwRg+y2Tm8NrjUGIcqK0NO+YErmYrNdPXHxkRlZ6yi5YASrZM/0UiDFiTva5R6QWJBzIceb1oxd85MvgFrf8dXcs3N4d63wAvCA9WuonxiXyg01DpC9ISsdoIcLAijNCzNXxXdU/buYtzk0JB0S8QusgMhDdHO13LcNkMO+iIaI2GYOkGYE3+rXJfshTSLtP0R97B4eLUUu64E33lnTtdVVkEdjibmO+EyII3wD7HGJBDMdPZgM6THmulwJ1SYnkkeGkvZp7KyGLsNBtfx5UGgTVYyNoiYceEhm1CTmC+8MNoIf0+nWCbZbbOOArq6NsuczvtTXtLlB9UtaSc9GMhSAtKqy9RjEBbHLRrrzIY28PLtm8P+ptPQ3Aus5o1gz8T7KPIkWjrmrw=
X-Forefront-Antispam-Report:
	CIP:192.30.252.208;CTRY:US;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:smtp.github.com;PTR:out-25.smtp.github.com;CAT:NONE;SFS:(13230016)(396003)(346002)(39860400002)(376002)(136003)(6266002)(26005)(966005)(107886003)(33964004)(498600001)(7636003)(166002)(356005)(83380400001)(121820200001)(2616005)(426003)(336012)(54906003)(30864003)(5660300002)(76236004)(6862004)(2906002)(19627405001)(36756003)(316002)(21615005)(786003)(70586007)(68406010)(8676002)(4326008)(19810500001)(43580500001);DIR:OUT;SFP:1101;
X-ExternalRecipientOutboundConnectors: 3326b102-c043-408b-a990-b89e477d582f
X-OriginatorOrg: alum.mit.edu
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 02 Sep 2022 18:02:59.4311
 (UTC)
X-MS-Exchange-CrossTenant-Network-Message-Id: 629e90d8-0fa9-42a1-5939-08da8d0d5f05
X-MS-Exchange-CrossTenant-Id: 3326b102-c043-408b-a990-b89e477d582f
X-MS-Exchange-CrossTenant-AuthSource: BN1NAM02FT005.eop-nam02.prod.protection.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Anonymous
X-MS-Exchange-CrossTenant-FromEntityHeader: Internet
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY5PR12MB6276
X-Received-Authentication-Results: (Received Authentication-Results header removed by mx1.messagingengine.com)
    spf=pass (sender IP is 192.30.252.208)
 smtp.mailfrom=github.com; dkim=pass (signature was verified)
 header.d=github.com;dmarc=pass action=none header.from=github.com;


----==_mimepart_631245531fc5f_3e85d4d02824f4
Content-Type: text/plain;
 charset=UTF-8
Content-Transfer-Encoding: 7bit

This issue proposes a resolution to the last outstanding question blocking `dyn` upcast.

## Background

We are trying to enable "upcasts" from a `dyn Trait` to its supertraits:

```rust
trait Foo {
    fn foo_method(&self);
}
trait Bar: Foo {
    fn bar_method(&self);
}

let x: &dyn Bar = /* ... */;
let y: &dyn Foo = x; // compiles
```

The key factor for these upcasts is that they require adjusting the vtable. The current implementation strategy is that the vtables for the `Bar` trait embed pointers to a `Foo` vtable within them:

```
+----------------------------+
| Bar vtable for some type T |
|----------------------------|
| Foo vtable                 | ----------> +------------------+
| foo_method                 | -----+      | Foo vtable for T |
| bar_method                 | --+  |      |------------------|
+----------------------------+   |  |      | foo_method       | ---+
                                 |  |      +------------------+    |
                                 |  |                              |
                                 |  +---> <T as Foo>::foo_method <+
                                 v
                 <T as Bar>::bar_method
                 
(this diagram is only meant to convey the general idea of the vtable
 layout, and doesn't represent the exact offsets we would use etc;
 in fact, with the current implementation,
 loads are only required for the non-left-most supertrait)
```

This way, given a `&dyn Bar` object, we convert its `Bar` vtable to the appropriate `Foo` vtable by loading the appropriate field.

Although we don't want to commit to a particular implementation strategy, we do want to leave room for this strategy. One implication is that performing an upcast may require loading from the vtable, which implies that the vtable must be a valid pointer to an actual Rust vtable. Although `&dyn Bar` references would always contain a valid vtable, the same is not necessarily true for a raw pointer like `*const dyn Bar` or `*mut dyn Bar`. 

In the language today, we only support "noop upcasts" that don't affect the vtable, and these are safe (e.g., converting from `*const dyn Foo + Send` to `*const dyn Foo`). If we extend the set of upcasts to permit vtable-adjusting upcasts, like `*const dyn Bar` to `*const dyn Foo`, this implies that, for safe code at least, all `*const dyn Trait` values must have a valid vtable, so that we know we can safely load the required field and perform the upcast.

On the other hand, we do not generally require raw `*mut T` pointers to point to valid data. In fact, we explicitly permit them to have any value, including null, and only require that they point to valid data when they are dereferenced. Because dereferencing a raw pointer is an unsafe operation, it has always been considered safe to expose an arbitrary raw pointer to unsafe code -- the unsafety arises when you take a raw pointer from an unknown source and dereference it, since unless you can trace the origin of that pointer you can't possible guarantee that it is valid to dereference.

This brings us to the conflict:

* It has historically been safe to "release" a raw pointer to safe code, but not safe to receive one (since you cannot know if it is valid).
* It has historically been safe to convert `*const dyn Foo + Send` to `*const dyn Foo`. 
    * Unlike the upcasts we are considering now, this upcast does not require changing the vtable at runtime, but the distinction is subtle for end-users.
    * Moreover, there are future extensions (e.g., upcasting `*const dyn Foo + Bar` to `*const dyn Foo`) that would require adjusting the vtable much like the upcasts currently being stabilized. 

## Related future consideration: virtual method calls on raw pointers

There have been requests to extend traits with the option to include raw pointer methods:

```rust
trait PtrLike {
    fn is_null(v: *const Self) -> bool;
}
```

These methods would be useful when writing unsafe code because having an `&self` method requires satisfying the validity conditions of an `&`-reference, which may not be possible. If we did have such methods, however, it raises the question of whether it would be safe to invoke `is_null` on a `*const dyn PtrLike` reference. Just as with upcasting, invoking a method from the vtable requires loading from the vtable, and hence requires a valid vtable generated by the compiler.

The solution we propose in this document also resolves this future dilemma.

## Contours of the solution space

We can fix this conflict in one of two basic ways:

* Make casts safe, but make it UB to have an invalid vtable: this implies that `*const dyn` types, at least in safe code, cannot be total garbage.
* Make casts unsafe.

**If upcasting dyn pointers remains safe, then we must ensure that raw pointer vtables are valid (i.e., point to a compiler-constructed vtable) whenever an upcast is performed (or, in the future, a method is invoked).** This implies that any raw pointer released to "unknown safe code" must have a valid vtable. There are a few options for how to make that guarantee:

* Minimal requirement:
    * It is UB to upcast a `*const dyn Foo` unless its vtable is valid, but it is not UB to have an invalid vtable otherwise.
    * Therefore, unsafe code that constructs a `*const dyn Foo` does not have to provide a valid vtable unless:
        * it performs a vtable-adjusting upcast
        * it releases that pointer to other code which is not known (because that code may then perform an upcast)
    * An implication of this rule is that `*const dyn Foo` values have no niche, because both the data and metadata pointer may contain arbitrary values. Note that `*const dyn Foo` values [currently have a niche](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=bcd18cd3870ba98e2c59b527418f8f68), though this is not a "guarantee".
* Middle requirement:
    * As above, it is UB to perform an upcast without a valid vtable.
    * But further, raw pointer vtables must always be word-aligned (and perhaps non-null).
    * This means that `*const dyn Foo` values have a niche (e.g., the value 1 is never a valid vtable), although `*const T` pointers (where `T: Sized`) do not (because they do not have a vtable as metadata).
* Maximal requirement:
    * Raw pointer vtables must always be valid vtables (and thus UB at the point of upcast is not possible, because the UB would already have occurred when the pointer was created in the first place).
    * This however makes it hard to create `*const dyn Foo` values -- you cannot simply use a null pointer for both the data and metadata pointer, for example, because that is not a valid vtable.

**Another alternative would be to safe that upcasting a `*const dyn Foo` is not safe so long as vtable adjustment is required.** Similarly, this would imply that invoking `*const Self` methods cannot be safe if `Self: ?Sized` (because it may be that `Self = dyn Trait` and hence would require a vtable load). This is quite difficult to implement and would require invasive changes to the `Coerce` trait for minimal benefit; it would also imply that `*const Self` methods cannot be safe if `Self: ?Sized` (because it may be that `Self = dyn Trait` and hence would require a vtable load). Neither of these changes is desirable, and the benefit of making those operations unsafe is very low, so we ruled out this option.
 
## Proposal

The proposal is to adopt the "middle requirement":

* It is UB to perform a "vtable-adjusting upcast" a `*const dyn Foo` unless its vtable is valid, but it is not UB to have an invalid vtable otherwise.
* The metadata for a `*const dyn Foo` or `*mut dyn Foo` value must always be word-aligned (this is its "validity invariant").
    * Null is considered a valid value.

Vtable-adjusting upcasts are defined as:

* Trait upcasts that alter the set of methods that can be invoked on the resulting value at runtime (e.g., `dyn Bar` to `dyn Foo` from the introduction). In particular, upcasts that simply add or remove auto-traits are not vtable-adjusting (e.g., `dyn Debug + Send` to `dyn Debug`).

This approach...

* permits safe upcasting and method calls;
* preserves the existing niche for `*const dyn`;
* permits zeroed `*const dyn` values.

The rules also imply that...

* valid vtables are only required for a `*dyn` pointer when
    * the `*dyn` pointer is upcast (or invoke methods);
    * or, when the `*dyn` pointer is released to arbitrary code, because that code may upcast (or invoke methods).
        * By implication, extending [`std::ptr::null`](https://doc.rust-lang.org/std/ptr/fn.null.html) to permit `T: ?Sized` would not be safe.

**Note that niches are, in general, not guaranteed to exist into the future.** That is, we reserve the right to loosen the validity invariant for `*const dyn` values in the future as this would strictly remove UB from the program.

## Concerns raised

RalfJung raised the concern that a validity invariant of "aligned but maybe null" is very unusual, and said it'd be more consistent to require "aligned and non-null". This would imply that `std::mem::zeroed` is not a valid way to initialize a `*const T` pointer if `T: ?Sized`. **This is not a 2-way door.** If we adopt the current proposal, code using `std::mem::zeroed` would not be UB, so we would have to accept it. On the other hand, adopting a stricter requirement ("aligned and non-null") is a 2-way door, as we can legally remove UB.

## Prior links

* [Dyn safety write-up](https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html), which includes links to prior write-ups
* [Exhaustive set of validity invariants considered](https://hackmd.io/z9GaT_vdRtazrmcF6pStvQ)

-- 
Reply to this email directly or view it on GitHub:
https://github.com/rust-lang/rust/issues/101336
You are receiving this because you are subscribed to this thread.

Message ID: <rust-lang/rust/issues/101336@github.com>
----==_mimepart_631245531fc5f_3e85d4d02824f4
Content-Type: text/html;
 charset=UTF-8
Content-Transfer-Encoding: 7bit

<p></p>
<p dir="auto">This issue proposes a resolution to the last outstanding question blocking <code class="notranslate">dyn</code> upcast.</p>
<h2 dir="auto">Background</h2>
<p dir="auto">We are trying to enable "upcasts" from a <code class="notranslate">dyn Trait</code> to its supertraits:</p>
<div class="highlight highlight-source-rust" dir="auto"><pre><span class="pl-k">trait</span> <span class="pl-smi">Foo</span> <span class="pl-kos">{</span>
    <span class="pl-k">fn</span> <span class="pl-en">foo_method</span><span class="pl-kos">(</span><span class="pl-c1">&amp;</span><span class="pl-smi">self</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span>
<span class="pl-k">trait</span> <span class="pl-smi">Bar</span><span class="pl-kos">:</span> <span class="pl-smi">Foo</span> <span class="pl-kos">{</span>
    <span class="pl-k">fn</span> <span class="pl-en">bar_method</span><span class="pl-kos">(</span><span class="pl-c1">&amp;</span><span class="pl-smi">self</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span>

<span class="pl-k">let</span> x<span class="pl-kos">:</span> <span class="pl-c1">&amp;</span><span class="pl-k">dyn</span> <span class="pl-smi">Bar</span> = <span class="pl-c">/* ... */</span><span class="pl-kos">;</span>
<span class="pl-k">let</span> y<span class="pl-kos">:</span> <span class="pl-c1">&amp;</span><span class="pl-k">dyn</span> <span class="pl-smi">Foo</span> = x<span class="pl-kos">;</span> <span class="pl-c">// compiles</span></pre></div>
<p dir="auto">The key factor for these upcasts is that they require adjusting the vtable. The current implementation strategy is that the vtables for the <code class="notranslate">Bar</code> trait embed pointers to a <code class="notranslate">Foo</code> vtable within them:</p>
<pre class="notranslate"><code class="notranslate">+----------------------------+
| Bar vtable for some type T |
|----------------------------|
| Foo vtable                 | ----------&gt; +------------------+
| foo_method                 | -----+      | Foo vtable for T |
| bar_method                 | --+  |      |------------------|
+----------------------------+   |  |      | foo_method       | ---+
                                 |  |      +------------------+    |
                                 |  |                              |
                                 |  +---&gt; &lt;T as Foo&gt;::foo_method &lt;+
                                 v
                 &lt;T as Bar&gt;::bar_method
                 
(this diagram is only meant to convey the general idea of the vtable
 layout, and doesn't represent the exact offsets we would use etc;
 in fact, with the current implementation,
 loads are only required for the non-left-most supertrait)
</code></pre>
<p dir="auto">This way, given a <code class="notranslate">&amp;dyn Bar</code> object, we convert its <code class="notranslate">Bar</code> vtable to the appropriate <code class="notranslate">Foo</code> vtable by loading the appropriate field.</p>
<p dir="auto">Although we don't want to commit to a particular implementation strategy, we do want to leave room for this strategy. One implication is that performing an upcast may require loading from the vtable, which implies that the vtable must be a valid pointer to an actual Rust vtable. Although <code class="notranslate">&amp;dyn Bar</code> references would always contain a valid vtable, the same is not necessarily true for a raw pointer like <code class="notranslate">*const dyn Bar</code> or <code class="notranslate">*mut dyn Bar</code>.</p>
<p dir="auto">In the language today, we only support "noop upcasts" that don't affect the vtable, and these are safe (e.g., converting from <code class="notranslate">*const dyn Foo + Send</code> to <code class="notranslate">*const dyn Foo</code>). If we extend the set of upcasts to permit vtable-adjusting upcasts, like <code class="notranslate">*const dyn Bar</code> to <code class="notranslate">*const dyn Foo</code>, this implies that, for safe code at least, all <code class="notranslate">*const dyn Trait</code> values must have a valid vtable, so that we know we can safely load the required field and perform the upcast.</p>
<p dir="auto">On the other hand, we do not generally require raw <code class="notranslate">*mut T</code> pointers to point to valid data. In fact, we explicitly permit them to have any value, including null, and only require that they point to valid data when they are dereferenced. Because dereferencing a raw pointer is an unsafe operation, it has always been considered safe to expose an arbitrary raw pointer to unsafe code -- the unsafety arises when you take a raw pointer from an unknown source and dereference it, since unless you can trace the origin of that pointer you can't possible guarantee that it is valid to dereference.</p>
<p dir="auto">This brings us to the conflict:</p>
<ul dir="auto">
<li>It has historically been safe to "release" a raw pointer to safe code, but not safe to receive one (since you cannot know if it is valid).</li>
<li>It has historically been safe to convert <code class="notranslate">*const dyn Foo + Send</code> to <code class="notranslate">*const dyn Foo</code>.
<ul dir="auto">
<li>Unlike the upcasts we are considering now, this upcast does not require changing the vtable at runtime, but the distinction is subtle for end-users.</li>
<li>Moreover, there are future extensions (e.g., upcasting <code class="notranslate">*const dyn Foo + Bar</code> to <code class="notranslate">*const dyn Foo</code>) that would require adjusting the vtable much like the upcasts currently being stabilized.</li>
</ul>
</li>
</ul>
<h2 dir="auto">Related future consideration: virtual method calls on raw pointers</h2>
<p dir="auto">There have been requests to extend traits with the option to include raw pointer methods:</p>
<div class="highlight highlight-source-rust" dir="auto"><pre><span class="pl-k">trait</span> <span class="pl-smi">PtrLike</span> <span class="pl-kos">{</span>
    <span class="pl-k">fn</span> <span class="pl-en">is_null</span><span class="pl-kos">(</span><span class="pl-s1">v</span><span class="pl-kos">:</span> <span class="pl-c1">*</span><span class="pl-k">const</span> <span class="pl-smi">Self</span><span class="pl-kos">)</span> -&gt; <span class="pl-smi">bool</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span></pre></div>
<p dir="auto">These methods would be useful when writing unsafe code because having an <code class="notranslate">&amp;self</code> method requires satisfying the validity conditions of an <code class="notranslate">&amp;</code>-reference, which may not be possible. If we did have such methods, however, it raises the question of whether it would be safe to invoke <code class="notranslate">is_null</code> on a <code class="notranslate">*const dyn PtrLike</code> reference. Just as with upcasting, invoking a method from the vtable requires loading from the vtable, and hence requires a valid vtable generated by the compiler.</p>
<p dir="auto">The solution we propose in this document also resolves this future dilemma.</p>
<h2 dir="auto">Contours of the solution space</h2>
<p dir="auto">We can fix this conflict in one of two basic ways:</p>
<ul dir="auto">
<li>Make casts safe, but make it UB to have an invalid vtable: this implies that <code class="notranslate">*const dyn</code> types, at least in safe code, cannot be total garbage.</li>
<li>Make casts unsafe.</li>
</ul>
<p dir="auto"><strong>If upcasting dyn pointers remains safe, then we must ensure that raw pointer vtables are valid (i.e., point to a compiler-constructed vtable) whenever an upcast is performed (or, in the future, a method is invoked).</strong> This implies that any raw pointer released to "unknown safe code" must have a valid vtable. There are a few options for how to make that guarantee:</p>
<ul dir="auto">
<li>Minimal requirement:
<ul dir="auto">
<li>It is UB to upcast a <code class="notranslate">*const dyn Foo</code> unless its vtable is valid, but it is not UB to have an invalid vtable otherwise.</li>
<li>Therefore, unsafe code that constructs a <code class="notranslate">*const dyn Foo</code> does not have to provide a valid vtable unless:
<ul dir="auto">
<li>it performs a vtable-adjusting upcast</li>
<li>it releases that pointer to other code which is not known (because that code may then perform an upcast)</li>
</ul>
</li>
<li>An implication of this rule is that <code class="notranslate">*const dyn Foo</code> values have no niche, because both the data and metadata pointer may contain arbitrary values. Note that <code class="notranslate">*const dyn Foo</code> values <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=bcd18cd3870ba98e2c59b527418f8f68" rel="nofollow">currently have a niche</a>, though this is not a "guarantee".</li>
</ul>
</li>
<li>Middle requirement:
<ul dir="auto">
<li>As above, it is UB to perform an upcast without a valid vtable.</li>
<li>But further, raw pointer vtables must always be word-aligned (and perhaps non-null).</li>
<li>This means that <code class="notranslate">*const dyn Foo</code> values have a niche (e.g., the value 1 is never a valid vtable), although <code class="notranslate">*const T</code> pointers (where <code class="notranslate">T: Sized</code>) do not (because they do not have a vtable as metadata).</li>
</ul>
</li>
<li>Maximal requirement:
<ul dir="auto">
<li>Raw pointer vtables must always be valid vtables (and thus UB at the point of upcast is not possible, because the UB would already have occurred when the pointer was created in the first place).</li>
<li>This however makes it hard to create <code class="notranslate">*const dyn Foo</code> values -- you cannot simply use a null pointer for both the data and metadata pointer, for example, because that is not a valid vtable.</li>
</ul>
</li>
</ul>
<p dir="auto"><strong>Another alternative would be to safe that upcasting a <code class="notranslate">*const dyn Foo</code> is not safe so long as vtable adjustment is required.</strong> Similarly, this would imply that invoking <code class="notranslate">*const Self</code> methods cannot be safe if <code class="notranslate">Self: ?Sized</code> (because it may be that <code class="notranslate">Self = dyn Trait</code> and hence would require a vtable load). This is quite difficult to implement and would require invasive changes to the <code class="notranslate">Coerce</code> trait for minimal benefit; it would also imply that <code class="notranslate">*const Self</code> methods cannot be safe if <code class="notranslate">Self: ?Sized</code> (because it may be that <code class="notranslate">Self = dyn Trait</code> and hence would require a vtable load). Neither of these changes is desirable, and the benefit of making those operations unsafe is very low, so we ruled out this option.</p>
<h2 dir="auto">Proposal</h2>
<p dir="auto">The proposal is to adopt the "middle requirement":</p>
<ul dir="auto">
<li>It is UB to perform a "vtable-adjusting upcast" a <code class="notranslate">*const dyn Foo</code> unless its vtable is valid, but it is not UB to have an invalid vtable otherwise.</li>
<li>The metadata for a <code class="notranslate">*const dyn Foo</code> or <code class="notranslate">*mut dyn Foo</code> value must always be word-aligned (this is its "validity invariant").
<ul dir="auto">
<li>Null is considered a valid value.</li>
</ul>
</li>
</ul>
<p dir="auto">Vtable-adjusting upcasts are defined as:</p>
<ul dir="auto">
<li>Trait upcasts that alter the set of methods that can be invoked on the resulting value at runtime (e.g., <code class="notranslate">dyn Bar</code> to <code class="notranslate">dyn Foo</code> from the introduction). In particular, upcasts that simply add or remove auto-traits are not vtable-adjusting (e.g., <code class="notranslate">dyn Debug + Send</code> to <code class="notranslate">dyn Debug</code>).</li>
</ul>
<p dir="auto">This approach...</p>
<ul dir="auto">
<li>permits safe upcasting and method calls;</li>
<li>preserves the existing niche for <code class="notranslate">*const dyn</code>;</li>
<li>permits zeroed <code class="notranslate">*const dyn</code> values.</li>
</ul>
<p dir="auto">The rules also imply that...</p>
<ul dir="auto">
<li>valid vtables are only required for a <code class="notranslate">*dyn</code> pointer when
<ul dir="auto">
<li>the <code class="notranslate">*dyn</code> pointer is upcast (or invoke methods);</li>
<li>or, when the <code class="notranslate">*dyn</code> pointer is released to arbitrary code, because that code may upcast (or invoke methods).
<ul dir="auto">
<li>By implication, extending <a href="https://doc.rust-lang.org/std/ptr/fn.null.html" rel="nofollow"><code class="notranslate">std::ptr::null</code></a> to permit <code class="notranslate">T: ?Sized</code> would not be safe.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p dir="auto"><strong>Note that niches are, in general, not guaranteed to exist into the future.</strong> That is, we reserve the right to loosen the validity invariant for <code class="notranslate">*const dyn</code> values in the future as this would strictly remove UB from the program.</p>
<h2 dir="auto">Concerns raised</h2>
<p dir="auto">RalfJung raised the concern that a validity invariant of "aligned but maybe null" is very unusual, and said it'd be more consistent to require "aligned and non-null". This would imply that <code class="notranslate">std::mem::zeroed</code> is not a valid way to initialize a <code class="notranslate">*const T</code> pointer if <code class="notranslate">T: ?Sized</code>. <strong>This is not a 2-way door.</strong> If we adopt the current proposal, code using <code class="notranslate">std::mem::zeroed</code> would not be UB, so we would have to accept it. On the other hand, adopting a stricter requirement ("aligned and non-null") is a 2-way door, as we can legally remove UB.</p>
<h2 dir="auto">Prior links</h2>
<ul dir="auto">
<li><a href="https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html" rel="nofollow">Dyn safety write-up</a>, which includes links to prior write-ups</li>
<li><a href="https://hackmd.io/z9GaT_vdRtazrmcF6pStvQ" rel="nofollow">Exhaustive set of validity invariants considered</a></li>
</ul>

<p style="font-size:small;-webkit-text-size-adjust:none;color:#666;">&mdash;<br />Reply to this email directly, <a href="https://github.com/rust-lang/rust/issues/101336">view it on GitHub</a>, or <a href="https://github.com/notifications/unsubscribe-auth/AABF4ZQAMRUAE4YLRQXDWNTV4I6NHANCNFSM6AAAAAAQDPIXP4">unsubscribe</a>.<br />You are receiving this because you are subscribed to this thread.<img src="https://github.com/notifications/beacon/AABF4ZRV4RO6N5424NRFCZTV4I6NHA5CNFSM6AAAAAAQDPIXP6WGG33NNVSW45C7OR4XAZNFJFZXG5LFVJRW63LNMVXHIX3JMTHFCFZ3V4.gif" height="1" width="1" alt="" /><span style="color: transparent; font-size: 0; display: none; visibility: hidden; overflow: hidden; opacity: 0; width: 0; height: 0; max-width: 0; max-height: 0; mso-hide: all">Message ID: <span>&lt;rust-lang/rust/issues/101336</span><span>@</span><span>github</span><span>.</span><span>com&gt;</span></span></p>
<script type="application/ld+json">[
{
"@context": "http://schema.org",
"@type": "EmailMessage",
"potentialAction": {
"@type": "ViewAction",
"target": "https://github.com/rust-lang/rust/issues/101336",
"url": "https://github.com/rust-lang/rust/issues/101336",
"name": "View Issue"
},
"description": "View this Issue on GitHub",
"publisher": {
"@type": "Organization",
"name": "GitHub",
"url": "https://github.com"
}
}
]</script>
----==_mimepart_631245531fc5f_3e85d4d02824f4--
